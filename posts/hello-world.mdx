---
title: Monte Carlo Portfolio Optimisation
---
This post contains a gentle introduction to procedural
macros in Rust and a guide to writing a procedural macro to
curry Rust functions. The source code for the entire library
can be found [here](https://github.com/nerdypepper/cutlass).
It is also available on [crates.io](https://crates.io/crates/cutlass).

The following links might prove to be useful before getting
started:

 - [Procedural Macros](https://doc.rust-lang.org/reference/procedural-macros.html)
 - [Currying](https://en.wikipedia.org/wiki/Currying)

Or you can pretend you read them, because I have included
a primer here :)

===

# Contents

 1. [Currying](#currying)  
 2. [Procedural Macros](#procedural-macros)  
 3. [Definitions](#definitions)  
 4. [Refinement](#refinement)  
 5. [The In-betweens](#the-in-betweens)  
 &nbsp;&nbsp;&nbsp;&nbsp; 5.1 [Dependencies](#dependencies)  
 &nbsp;&nbsp;&nbsp;&nbsp; 5.2 [The attribute macro](#the-attribute-macro)  
 &nbsp;&nbsp;&nbsp;&nbsp; 5.3 [Function Body](#function-body)  
 &nbsp;&nbsp;&nbsp;&nbsp; 5.4 [Function Signature](#function-signature)  
 &nbsp;&nbsp;&nbsp;&nbsp; 5.5 [Getting it together](#getting-it-together)  
 6. [Debugging and Testing](#debugging-and-testing)  
 7. [Notes](#notes)  
 8. [Conclusion](#conclusion)  


===

# Currying

Currying is the process of transformation of a function call
like `f(a, b, c)` to `f(a)(b)(c)`. A curried function
returns a concrete value only when it receives all its
arguments! If it does recieve an insufficient amount of
arguments, say 1 of 3, it returns a *curried function*, that
returns after receiving 2 arguments.

===

```
curry(f(a, b, c)) = h(a)(b)(c)

h(x) = g   <- curried function that takes upto 2 args (g)
g(y) = k   <- curried function that takes upto 1 arg (k)
k(z) = v   <- a value (v)

Keen readers will conclude the following,
h(x)(y)(z) = g(y)(z) = k(z) = v
```

===

Mathematically, if `f` is a function that takes two
arguments `x` and `y`, such that `x ϵ X`, and `y ϵ Y` , we
write it as:

===

```
f: (X × Y) -> Z
```

===

where `×` denotes the Cartesian product of set `X` and `Y`,
and curried `f` (denoted by `h` here) is written as:

===

```
h: X -> (Y -> Z)
```

===

# Procedural Macros

These are functions that take code as input and spit out
modified code as output. Powerful stuff. Rust has three
kinds of proc-macros:

 - Function like macros  
 - Derive macros: `#[derive(...)]`, used to automatically
   implement traits for structs/enums  
 - and Attribute macros: `#[test]`, usually slapped onto
   functions  

We will be using Attribute macros to convert a Rust function
into a curried Rust function, which we should be able to
call via: `function(arg1)(arg2)`.

===

===

# Definitions

Being respectable programmers, we define the input to and
the output from our proc-macro. Here's a good non-trivial
function to start out with:

===

```rust
fn add(x: u32, y: u32, z: u32) -> u32 {
  return x + y + z;
}
```

===

Hmm, what would our output look like? What should our
proc-macro generate ideally? Well, if we understood currying
correctly, we should accept an argument and return a
function that accepts an argument and returns ... you get
the point. Something like this should do:

===

```rust
fn add_curried1(x: u32) -> ? {
  return fn add_curried2 (y: u32) -> ? {
    return fn add_curried3 (z: u32) -> u32 {
      return x + y + z;
    }
  }
}
```

===

# Return types

We have placed `?`s in place of return
types. Let's try to fix that. `add_curried3` returns the
'value', so `u32` is accurate. `add_curried2` returns
`add_curried3`. What is the type of `add_curried3`? It is a
function that takes in a `u32` and returns a `u32`.  So a
`fn(u32) -> u32` will do right? No, I'll explain why in the
next point, but for now, we will make use of the `Fn` trait,
our return type is `impl Fn(u32) -> u32`. This basically
tells the compiler that we will be returning something
function-like, a.k.a, behaves like a `Fn`. Cool! 

===

===

If you have been following along, you should be able to tell
that the return type of `add_curried1` is:

===

```
impl Fn(u32) -> (impl Fn(u32) -> u32)
```

===

We can drop the parentheses because `->` is right associative:

===

```
impl Fn(u32) -> impl Fn(u32) -> u32

```

===

**Accessing environment**  
 A function cannot access it's environment. Our solution
will not work. `add_curried3` attempts to access `x`, which
is not allowed! A closure[^closure] however, can. If we are
returning a closure, our return type must be `impl Fn`, and
not `fn`.  The difference between the `Fn` trait and
function pointers is beyond the scope of this post.

[^closure]: [https://doc.rust-lang.org/book/ch13-01-closures.html](https://doc.rust-lang.org/book/ch13-01-closures.html)


# Refinement

Armed with knowledge, we refine our expected output, this
time, employing closures:

===

```rust
fn add(x: u32) -> impl Fn(u32) -> impl Fn(u32) -> u32 {
  return move |y| move |z| x + y + z;
}
```

===

Alas, that does not compile either! It errors out with the
following message:

===

```
error[E0562]: `impl Trait` not allowed outside of function
and inherent method return types
  --> src/main.rs:17:37
   |
   | fn add(x: u32) -> impl Fn(u32) -> impl Fn(u32) -> u32
   |                                   ^^^^^^^^^^^^^^^^^^^

```

===

You are allowed to return an `impl Fn` only inside a
function. We are currently returning it from another return!
Or at least, that was the most I could make out of the error
message.

We are going to have to cheat a bit to fix this issue; with
type aliases and a convenient nightly feature [^features]:

[^features]: [caniuse.rs](https://caniuse.rs) contains an
  indexed list of features and their status.

===

```rust
#![feature(type_alias_impl_trait)]  // allows us to use `impl Fn` in type aliases!

type T0 = u32;                 // the return value when zero args are to be applied
type T1 = impl Fn(u32) -> T0;  // the return value when one arg is to be applied
type T2 = impl Fn(u32) -> T1;  // the return value when two args are to be applied

fn add(x: u32) -> T2 {
  return move |y| move |z| x + y + z;
}
```

===

Drop that into a cargo project, call `add(4)(5)(6)`, cross
your fingers, and run `cargo +nightly run`. You should see a
15 unless you forgot to print it!

# The In-Betweens

Let us write the magical bits that take us from function to
curried function. 

Initialize your workspace with `cargo new --lib currying`.
Proc-macro crates are libraries with exactly one export, the
macro itself. Add a `tests` directory to your crate root.
Your directory should look something like this:

===

```
.
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── smoke.rs
```

===

# Dependencies

We will be using a total of 3 external crates:

 - [proc_macro2](https://docs.rs/proc-macro2/1.0.12/proc_macro2/)
 - [syn](https://docs.rs/syn/1.0.18/syn/index.html)
 - [quote](https://docs.rs/quote/1.0.4/quote/index.html)

Here's a sample `Cargo.toml`:

===

```
# Cargo.toml

[dependencies]
proc-macro2 = "1.0.9"
quote = "1.0"

[dependencies.syn]
version = "1.0"
features = ["full"]

[lib]
proc-macro = true  # this is important!
```

